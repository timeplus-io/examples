input {
  kafka {
    bootstrap_servers => "redpanda:9092"
    topics => ["cisco_asa_logs"]
    codec => json
    consumer_threads => 1
    group_id => "logstash-cisco-asa-parser"
    auto_offset_reset => "earliest"
  }
}

filter {
  # The incoming Kafka message already has the message parsed as JSON
  # So we work with the "message" field directly
  
  # ============================================================
  # STEP 1: Parse the ASA syslog header
  # ============================================================
  grok {
    match => {
      "message" => "<%{POSINT:priority}>%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:device} %%{WORD:facility}-%{INT:severity}-%{INT:event_id}: %{GREEDYDATA:asa_message}"
    }
  }

  # ============================================================
  # STEP 2: Branch based on event_id and parse message details
  # ============================================================
  
  # 302013: Built TCP Connection
  if [event_id] == "302013" {
    grok {
      match => {
        "asa_message" => "Built %{DATA:direction} %{DATA:protocol} connection %{INT:connection_id} for %{DATA:src_interface}:%{IP:src_ip}\/%{INT:src_port} \(%{IP:nat_src_ip}\/%{INT:nat_src_port}\) to %{DATA:dst_interface}:%{IP:dst_ip}\/%{INT:dst_port} \(%{IP:nat_dst_ip}\/%{INT:nat_dst_port}\)"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
        "connection_id" => "integer"
        "nat_src_port" => "integer"
        "nat_dst_port" => "integer"
      }
    }
  }
  
  # 302014: Teardown TCP Connection
  else if [event_id] == "302014" {
    grok {
      match => {
        "asa_message" => "Teardown %{DATA:protocol} connection %{INT:connection_id} for %{DATA:src_interface}:%{IP:src_ip}\/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}\/%{INT:dst_port} duration %{DATA:duration} bytes %{INT:bytes} %{GREEDYDATA:reason}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
        "connection_id" => "integer"
        "bytes" => "integer"
      }
    }
  }
  
  # 302015: Built UDP Connection
  else if [event_id] == "302015" {
    grok {
      match => {
        "asa_message" => "Built %{DATA:direction} %{DATA:protocol} connection %{INT:connection_id} for %{DATA:src_interface}:%{IP:src_ip}\/%{INT:src_port} \(%{IP:nat_src_ip}\/%{INT:nat_src_port}\) to %{DATA:dst_interface}:%{IP:dst_ip}\/%{INT:dst_port} \(%{IP:nat_dst_ip}\/%{INT:nat_dst_port}\)"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
        "connection_id" => "integer"
        "nat_src_port" => "integer"
        "nat_dst_port" => "integer"
      }
    }
  }
  
  # 302016: Teardown UDP Connection
  else if [event_id] == "302016" {
    grok {
      match => {
        "asa_message" => "Teardown %{DATA:protocol} connection %{INT:connection_id} for %{DATA:src_interface}:%{IP:src_ip}\/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}\/%{INT:dst_port} duration %{DATA:duration} bytes %{INT:bytes}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
        "connection_id" => "integer"
        "bytes" => "integer"
      }
    }
  }
  
  # 302020: Built ICMP Connection
  else if [event_id] == "302020" {
    grok {
      match => {
        "asa_message" => "Built %{DATA:direction} ICMP connection for faddr %{IP:faddr}\/0 gaddr %{IP:gaddr}\/0 laddr %{IP:laddr}\/0"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # 302021: Teardown ICMP Connection
  else if [event_id] == "302021" {
    grok {
      match => {
        "asa_message" => "Teardown ICMP connection for faddr %{IP:faddr}\/0 gaddr %{IP:gaddr}\/0 laddr %{IP:laddr}\/0 duration %{DATA:duration} bytes %{INT:bytes}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { "bytes" => "integer" }
    }
  }
  
  # 305011: Built Dynamic Translation
  else if [event_id] == "305011" {
    grok {
      match => {
        "asa_message" => "Built dynamic %{DATA:protocol} translation from %{DATA:src_interface}:%{IP:src_ip}\/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}\/%{INT:dst_port}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
      }
    }
  }
  
  # 305012: Teardown Dynamic Translation
  else if [event_id] == "305012" {
    grok {
      match => {
        "asa_message" => "Teardown dynamic %{DATA:protocol} translation from %{DATA:src_interface}:%{IP:src_ip}\/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}\/%{INT:dst_port} duration %{DATA:duration}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
      }
    }
  }
  
  # 106023: Deny tcp/udp by ACL
  else if [event_id] == "106023" {
    grok {
      match => {
        "asa_message" => "Deny %{DATA:protocol} src %{DATA:src_interface}:%{IP:src_ip}\/%{INT:src_port} dst %{DATA:dst_interface}:%{IP:dst_ip}\/%{INT:dst_port} by access-group \"%{DATA:acl_name}\" \[%{DATA:hex_codes}\]"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
      }
    }
  }
  
  # 106015: Deny TCP (no connection)
  else if [event_id] == "106015" {
    grok {
      match => {
        "asa_message" => "Deny %{DATA:protocol} \(no connection\) from %{IP:src_ip}\/%{INT:src_port} to %{IP:dst_ip}\/%{INT:dst_port} flags %{DATA:tcp_flags} on interface %{DATA:interface}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "src_port" => "integer" 
        "dst_port" => "integer" 
      }
    }
  }
  
  # 106001: Deny reverse path check
  else if [event_id] == "106001" {
    grok {
      match => {
        "asa_message" => "Deny %{DATA:protocol} reverse path check from %{IP:src_ip} to %{IP:dst_ip} on interface %{DATA:interface}"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # 313001: Denied ICMP
  else if [event_id] == "313001" {
    grok {
      match => {
        "asa_message" => "Denied ICMP type=%{INT:icmp_type}, code=%{INT:icmp_code} from %{IP:src_ip} on interface %{DATA:interface}%{GREEDYDATA:reason}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { 
        "icmp_type" => "integer" 
        "icmp_code" => "integer" 
      }
    }
  }
  
  # 313004: Denied ICMP (no matching session)
  else if [event_id] == "313004" {
    grok {
      match => {
        "asa_message" => "Denied ICMP type=%{INT:icmp_type}, from laddr %{IP:src_ip} on interface %{DATA:interface} to %{IP:dst_ip}: %{GREEDYDATA:reason}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { "icmp_type" => "integer" }
    }
  }
  
  # 313005: No matching connection for ICMP error
  else if [event_id] == "313005" {
    grok {
      match => {
        "asa_message" => "No matching connection for ICMP error message: %{GREEDYDATA:icmp_details}"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # 400013: IDS Alert
  else if [event_id] == "400013" {
    grok {
      match => {
        "asa_message" => "IDS:%{INT:ids_signature} ICMP echo request from %{IP:src_ip} to %{IP:dst_ip} on interface %{DATA:interface}"
      }
      remove_field => ["asa_message"]
    }
    mutate {
      convert => { "ids_signature" => "integer" }
    }
  }
  
  # 113004: AAA Authentication Successful
  else if [event_id] == "113004" {
    grok {
      match => {
        "asa_message" => "AAA user authentication Successful: server = %{IP:aaa_server}, user = %{DATA:username}"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # 113015: AAA Authentication Rejected
  else if [event_id] == "113015" {
    grok {
      match => {
        "asa_message" => "AAA user authentication Rejected: reason = %{DATA:auth_reason}: user = %{DATA:username}, server = %{IP:aaa_server}"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # 713172: VPN IP Assignment
  else if [event_id] == "713172" {
    grok {
      match => {
        "asa_message" => "Group = %{DATA:vpn_group}, IP = %{IP:public_ip}, Assigned private IP = %{IP:private_ip}"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # 718012: HELLO request (from your sample data)
  else if [event_id] == "718012" {
    grok {
      match => {
        "asa_message" => "Sent HELLO request to %{IP:target_ip}"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # 101002: Failover cable issue (from your sample data)
  else if [event_id] == "101002" {
    grok {
      match => {
        "asa_message" => "\(%{DATA:failover_state}\) %{GREEDYDATA:error_message}"
      }
      remove_field => ["asa_message"]
    }
  }
  
  # ============================================================
  # STEP 3: Convert common fields to proper types
  # ============================================================
  mutate {
    convert => { 
      "priority" => "integer"
      "severity" => "integer"
      "event_id" => "integer"
    }
  }
  
  # ============================================================
  # STEP 4: Add timestamp parsing
  # ============================================================
  date {
    match => [ "timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss" ]
    target => "@timestamp"
  }
  
  # Add a field to mark successful parsing
  mutate {
    add_field => { "parsed" => "true" }
  }
  
  # Remove Kafka metadata fields if not needed
  mutate {
    remove_field => ["@version"]
  }
}

output {
  # Output to Kafka topic for parsed logs
  kafka {
    bootstrap_servers => "redpanda:9092"
    topic_id => "cisco_asa_parsed_logstash"
    codec => json
  }
  
  # Optional: Output to stdout for debugging
  stdout {
    codec => rubydebug
  }
}