const uda = {
  has_customized_emit: true,

  initialize: function () {
    // keep history of all orders with hashmap, 
    // first layer key is side, 
    // second layer key is symbol,
    // third layer key is price
    this.orders = {
      'buy': {},
      'sell': {}
    };
    this.executions = []; // executions generated by current batch of orders
    this.order_sequence = []; // sequence of orders generated by current batch
  },

  process: function (Time, OrderId, Symbol, Side, OrderQty, OrderType, Price) {
    const executions = [];
    const current_time = new Date();
    for (let i = 0; i < OrderId.length; i++) {
      const current_order = {
        Time: Time[i],
        OrderId: OrderId[i],
        Symbol: Symbol[i],
        Side: Side[i],
        OrderQty: OrderQty[i],
        OrderType: OrderType[i],
        Price: Price[i],
        Status: "Pending",
        FilledQty: 0,
        AvailableQty: OrderQty[i],
      };

      if (!this.orders[current_order.Side].hasOwnProperty(current_order.Symbol)) {
        // create entry for symbol
        this.orders[current_order.Side][current_order.Symbol] = {};
      }

      if (!this.orders[current_order.Side][current_order.Symbol].hasOwnProperty(current_order.Price)) {
        // create orders for specific price
        this.orders[current_order.Side][current_order.Symbol][current_order.Price] = [];
      }

      // append current order to the queue of the order map
      this.orders[current_order.Side][current_order.Symbol][current_order.Price].push(current_order);

      // copy current order into order sequence
      this.order_sequence.push({ ...current_order });

      while (true) {
        const other_side = current_order.Side === 'sell' ? 'buy' : 'sell';
        // no any order with same price on the other side
        if (!this.orders[other_side].hasOwnProperty(current_order.Symbol)) {
          break;
        }

        if (!this.orders[other_side][current_order.Symbol].hasOwnProperty(current_order.Price)) {
          break;
        }

        if (this.orders[other_side][current_order.Symbol][current_order.Price].length == 0) {
          break;
        }

        let match_order = this.orders[other_side][current_order.Symbol][current_order.Price][0];

        if (!current_order.AvailableQty > 0) {
          break;
        }

        let execution_qty = 0;
        if (match_order.AvailableQty > current_order.AvailableQty) {
          execution_qty = current_order.AvailableQty;
          match_order.AvailableQty -= execution_qty;
          match_order.FilledQty += execution_qty;
          match_order.Status = "Partially Filled";
          current_order.FilledQty = current_order.OrderQty;
          current_order.AvailableQty = 0;
          current_order.Status = "Filled";
        } else if (match_order.AvailableQty < current_order.AvailableQty) {
          execution_qty = match_order.AvailableQty;
          current_order.FilledQty += execution_qty;
          current_order.AvailableQty -= execution_qty;
          current_order.Status = "Partially Filled";
          match_order.Status = "Filled";
          match_order.AvailableQty = 0;
          match_order.FilledQty = match_order.OrderQty;
        } else {
          execution_qty = current_order.OrderQty;
          match_order.AvailableQty = 0;
          match_order.FilledQty = match_order.OrderQty;
          match_order.Status = "Filled";
          current_order.FilledQty = current_order.OrderQty;
          current_order.AvailableQty = 0;
          current_order.Status = "Filled";
        }

        // add updated buy/sell order to sequence
        const match_order_update = { ...match_order };
        match_order_update.Time = current_time;

        this.order_sequence.push(match_order_update);
        this.order_sequence.push({ ...current_order });

        if (current_order.Side === "buy") {
          executions.push({
            Time: current_time,
            BuyId: current_order.OrderId,
            SellId: match_order.OrderId,
            Symbol: current_order.Symbol,
            Price: current_order.Price,
            Qty: execution_qty,
          });
        } else {
          executions.push({
            Time: current_time,
            BuyId: match_order.OrderId,
            SellId: current_order.OrderId,
            Symbol: current_order.Symbol,
            Price: current_order.Price,
            Qty: execution_qty,
          });
        }

        // remove filled orders 
        if (match_order.Status === 'Filled') {
          this.orders[other_side][current_order.Symbol][current_order.Price] = this.orders[other_side][current_order.Symbol][current_order.Price].slice(1);
        }
      
        if ( current_order.Status === "Filled" ) {
          this.orders[current_order.Side][current_order.Symbol][current_order.Price] = this.orders[current_order.Side][current_order.Symbol][current_order.Price].slice(0, -1);
        }
      }
    }
    this.executions = executions;
    return this.order_sequence.length;
  },

  finalize: function () {
    const orders = this.order_sequence;
    this.executions = [];
    this.order_sequence = [];
    return orders;
  },
};

module.exports = uda;

